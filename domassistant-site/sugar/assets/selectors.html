  <div class="head">
   <p><a href="http://www.w3.org/"><img height=48 alt=W3C src="" width=72></a>

   <h1 id="title">Selectors</h1>

   <h2>W3C Working Draft 15 December 2005</h2>

   <p class="copyright"><a
   href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">
   Copyright</a> &copy; 2005 <a href="http://www.w3.org/"><abbr
   title="World Wide Web Consortium">W3C</abbr></a><sup>&reg;</sup>
   (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts
   Institute of Technology">MIT</abbr></a>, <a
   href="http://www.ercim.org/"><acronym title="European Research
   Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a
   href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.  W3C
   <a
   href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a
   href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>,
   <a
   href="http://www.w3.org/Consortium/Legal/copyright-documents">document
   use</a> rules apply.

   <hr title="Separator for header">

  </div>

  <h2><a name=abstract></a>Abstract</h2>

  <p><em>Selectors</em> are patterns that match against elements in a
  tree. Selectors have been optimized for use with HTML and XML, and
  are designed to be usable in performance-critical code.</p>

  <p><acronym title="Cascading Style Sheets">CSS</acronym> (Cascading
  Style Sheets) is a language for describing the rendering of <acronym
  title="Hypertext Markup Language">HTML</acronym> and <acronym
  title="Extensible Markup Language">XML</acronym> documents on
  screen, on paper, in speech, etc. CSS uses Selectors for binding
  style properties to elements in the document. This document
  describes extensions to the selectors defined in CSS level 2. These
  extended selectors will be used by CSS level 3.

  <p>Selectors define the following function:</p>

  <pre>expression &#x2217; element &rarr; boolean</pre>

  <p>That is, given an element and a selector, this specification
  defines whether that element matches the selector.</p>

  <p>These expressions can also be used, for instance, to select a set
  of elements, or a single element from a set of elements, by
  evaluating the expression across all the elements in a
  subtree. <acronym title="Simple Tree Transformation
  Sheets">STTS</acronym> (Simple Tree Transformation Sheets), a
  language for transforming XML trees, uses this mechanism. <a href="#refsSTTS">[STTS]</a></p>

  <h2><a name=status></a>Status of this document</h2>

  <p><em>This section describes the status of this document at the
  time of its publication. Other documents may supersede this
  document. A list of current W3C publications and the latest revision
  of this technical report can be found in the <a
  href="http://www.w3.org/TR/">W3C technical reports index at
  http://www.w3.org/TR/.</a></em></p>

  <p>This document describes the selectors that already exist in <a
  href="#refsCSS1"><abbr title="CSS level 1">CSS1</abbr></a> and <a
  href="#refsCSS21"><abbr title="CSS level 2">CSS2</abbr></a>, and
  also proposes new selectors for <abbr title="CSS level
  3">CSS3</abbr> and other languages that may need them.</p>

  <p>The CSS Working Group doesn't expect that all implementations of
  CSS3 will have to implement all selectors. Instead, there will
  probably be a small number of variants of CSS3, called profiles. For
  example, it may be that only a profile for interactive user agents
  will include all of the selectors.</p>

  <p>This specification is a last call working draft for the the <a
  href="http://www.w3.org/Style/CSS/members">CSS Working Group</a>
  (<a href="/Style/">Style Activity</a>). This
  document is a revision of the <a
  href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/">Candidate
  Recommendation dated 2001 November 13</a>, and has incorporated
  implementation feedback received in the past few years. It is
  expected that this last call will proceed straight to Proposed
  Recommendation stage since it is believed that interoperability will
  be demonstrable.</p>

  <p>All persons are encouraged to review and implement this
  specification and return comments to the (<a
  href="http://lists.w3.org/Archives/Public/www-style/">archived</a>)
  public mailing list <a
  href="http://www.w3.org/Mail/Lists.html#www-style">www-style</a>
  (see <a href="http://www.w3.org/Mail/Request">instructions</a>). W3C
  Members can also send comments directly to the CSS Working
  Group.
  The deadline for comments is 14 January 2006.</p>

  <p>This is still a draft document and may be updated, replaced, or
  obsoleted by other documents at any time. It is inappropriate to
  cite a W3C Working Draft as other than &quot;work in progress&quot;.

  <p>This document may be available in <a
  href="http://www.w3.org/Style/css3-selectors-updates/translations">translation</a>.
  The English version of this specification is the only normative
  version.

  <div class="subtoc">

   <h2><a name=contents>Table of contents</a></h2>

   <ul class="toc">
    <li class="tocline2"><a href="#context">1. Introduction</a>
     <ul>
      <li><a href="#dependencies">1.1. Dependencies</a> </li>
      <li><a href="#terminology">1.2. Terminology</a> </li>
      <li><a href="#changesFromCSS2">1.3. Changes from CSS2</a> </li>
     </ul>
    <li class="tocline2"><a href="#selectors">2. Selectors</a>
    <li class="tocline2"><a href="#casesens">3. Case sensitivity</a>
    <li class="tocline2"><a href="#selector-syntax">4. Selector syntax</a>
    <li class="tocline2"><a href="#grouping">5. Groups of selectors</a>
    <li><a href="#pseudo-elements">7. Pseudo-elements</a>
     <ul>
      <li><a href="#first-line">7.1. The ::first-line pseudo-element</a>
      <li><a href="#first-letter">7.2. The ::first-letter pseudo-element</a>
      <li><a href="#UIfragments">7.3. The ::selection pseudo-element</a>
      <li><a href="#gen-content">7.4. The ::before and ::after pseudo-elements</a></li>
     </ul>
    <li class="tocline2"><a href="#combinators">8. Combinators</a>
     <ul class="toc">
      <li class="tocline3"><a href="#descendant-combinators">8.1. Descendant combinators</a>
      <li class="tocline3"><a href="#child-combinators">8.2. Child combinators</a>
      <li class="tocline3"><a href="#sibling-combinators">8.3. Sibling combinators</a>
       <ul class="toc">
        <li class="tocline4"><a href="#adjacent-sibling-combinators">8.3.1. Adjacent sibling combinator</a>
        <li class="tocline4"><a href="#general-sibling-combinators">8.3.2. General sibling combinator</a></li>
       </ul>
      </li>
     </ul>
    <li class="tocline2"><a href="#specificity">9. Calculating a selector's specificity</a>
    <li class="tocline2"><a href="#w3cselgrammar">10. The grammar of Selectors</a>
     <ul class="toc">
      <li class="tocline3"><a href="#grammar">10.1. Grammar</a>
      <li class="tocline3"><a href="#lex">10.2. Lexical scanner</a></li>
     </ul>
    <li class="tocline2"><a href="#downlevel">11. Namespaces and down-level clients</a>
    <li class="tocline2"><a href="#profiling">12. Profiles</a>
    <li><a href="#Conformance">13. Conformance and requirements</a>
    <li><a href="#Tests">14. Tests</a>
    <li><a href="#ACKS">15. Acknowledgements</a>
    <li class="tocline2"><a href="#references">16. References</a>
   </ul>

  </div>

  <h2><a name=context>1. Introduction</a></h2>

  <h3><a name=dependencies></a>1.1. Dependencies</h3>

  <p>Some features of this specification are specific to CSS, or have
  particular limitations or rules specific to CSS. In this
  specification, these have been described in terms of CSS2.1. <a
  href="#refsCSS21">[CSS21]</a></p>

  <h3><a name=terminology></a>1.2. Terminology</h3>

  <p>All of the text of this specification is normative except
  examples, notes, and sections explicitly marked as
  non-normative.</p>

  <h3><a name=changesFromCSS2></a>1.3. Changes from CSS2</h3>
 
  <p><em>This section is non-normative.</em></p>

  <p>The main differences between the selectors in CSS2 and those in
  Selectors are:

  <ul>

   <li>the list of basic definitions (selector, group of selectors,
   simple selector, etc.) has been changed; in particular, what was
   referred to in CSS2 as a simple selector is now called a sequence
   of simple selectors, and the term "simple selector" is now used for
   the components of this sequence</li>

   <li>an optional namespace component is now allowed in type element
   selectors, the universal selector and attribute selectors</li>

   <li>a <a href="#general-sibling-combinators">new combinator</a> has been introduced</li>

   <li>new simple selectors including substring matching attribute
   selectors, and new pseudo-classes</li>

   <li>new pseudo-elements, and introduction of the "::" convention
   for pseudo-elements</li>

   <li>the grammar has been rewritten</li>

   <li>profiles to be added to specifications integrating Selectors
   and defining the set of selectors which is actually supported by
   each specification</li>

   <li>Selectors are now a CSS3 Module and an independent
   specification; other specifications can now refer to this document
   independently of CSS</li>

   <li>the specification now has its own test suite</li>

  </ul>

<h2><a name=selectors></a>2. Selectors</h2>

<p><em>This section is non-normative, as it merely summarizes the
following sections.</em></p>

<p>A Selector represents a structure. This structure can be used as a
condition (e.g. in a CSS rule) that determines which elements a
selector matches in the document tree, or as a flat description of the
HTML or XML fragment corresponding to that structure.</p>

<p>Selectors may range from simple element names to rich contextual
representations.</p>

<p>The following table summarizes the Selector syntax:</p>

<table class="selectorsReview">
  <thead>
  <tr>
    <th class="pattern">Pattern</th>
    <th class="meaning">Meaning</th>
    <th class="described">Described in section</th>
    <th class="origin">First defined in CSS level</th></tr>
  <tbody>
  <tr>
    <td class="pattern">*</td>
    <td class="meaning">any element</td>
    <td class="described"><a
      href="#universal-selector">Universal
      selector</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E</td>
    <td class="meaning">an element of type E</td>
    <td class="described"><a
      href="#type-selectors">Type selector</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E[foo]</td>
    <td class="meaning">an E element with a "foo" attribute</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value is exactly
      equal to "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo~="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value is a list of
      space-separated values, one of which is exactly equal to "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo^="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value begins exactly
      with the string "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo$="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value ends exactly
      with the string "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo*="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value contains the
      substring "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[hreflang|="en"]</td>
    <td class="meaning">an E element whose "hreflang" attribute has a hyphen-separated
      list of values beginning (from the left) with "en"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:root</td>
    <td class="meaning">an E element, root of the document</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-child(n)</td>
    <td class="meaning">an E element, the n-th child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-last-child(n)</td>
    <td class="meaning">an E element, the n-th child of its parent, counting
      from the last one</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-of-type(n)</td>
    <td class="meaning">an E element, the n-th sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-last-of-type(n)</td>
    <td class="meaning">an E element, the n-th sibling of its type, counting
      from the last one</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:first-child</td>
    <td class="meaning">an E element, first child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:last-child</td>
    <td class="meaning">an E element, last child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:first-of-type</td>
    <td class="meaning">an E element, first sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:last-of-type</td>
    <td class="meaning">an E element, last sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:only-child</td>
    <td class="meaning">an E element, only child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:only-of-type</td>
    <td class="meaning">an E element, only sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:empty</td>
    <td class="meaning">an E element that has no children (including text
    nodes)</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:link<br>E:visited</td>
    <td class="meaning">an E element being the source anchor of a hyperlink of
      which the target is not yet visited (:link) or already visited
    (:visited)</td>
    <td class="described"><a
      href="#link">The link
      pseudo-classes</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E:active<br>E:hover<br>E:focus</td>
    <td class="meaning">an E element during certain user actions</td>
    <td class="described"><a
      href="#useraction-pseudos">The user
      action pseudo-classes</a></td>
    <td class="origin">1 and 2</td></tr>
  <tr>
    <td class="pattern">E:target</td>
    <td class="meaning">an E element being the target of the referring URI</td>
    <td class="described"><a
      href="#target-pseudo">The target
      pseudo-class</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:lang(fr)</td>
    <td class="meaning">an element of type E in language "fr" (the document
      language specifies how language is determined)</td>
    <td class="described"><a
      href="#lang-pseudo">The :lang()
      pseudo-class</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:enabled<br>E:disabled</td>
    <td class="meaning">a user interface element E which is enabled or
    disabled</td>
    <td class="described"><a
      href="#UIstates">The UI element states
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:checked<!--<br>E:indeterminate--></td>
    <td class="meaning">a user interface element E which is checked<!-- or in an
      indeterminate state--> (for instance a radio-button or checkbox)</td>
    <td class="described"><a
      href="#UIstates">The UI element states
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E::first-line</td>
    <td class="meaning">the first formatted line of an E element</td>
    <td class="described"><a
      href="#first-line">The ::first-line
      pseudo-element</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E::first-letter</td>
    <td class="meaning">the first formatted letter of an E element</td>
    <td class="described"><a
      href="#first-letter">The ::first-letter
      pseudo-element</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E::selection</td>
    <td class="meaning">the portion of an E element that is currently
      selected/highlighted by the user</td>
    <td class="described"><a
      href="#UIfragments">The UI element
      fragments pseudo-elements</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E::before</td>
    <td class="meaning">generated content before an E element</td>
    <td class="described"><a
      href="#gen-content">The ::before
      pseudo-element</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E::after</td>
    <td class="meaning">generated content after an E element</td>
    <td class="described"><a
      href="#gen-content">The ::after
      pseudo-element</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E.warning</td>
    <td class="meaning">an E element whose class is
"warning" (the document language specifies how class is determined).</td>
    <td class="described"><a
      href="#class-html">Class
    selectors</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E#myid</td>
    <td class="meaning">an E element with ID equal to "myid".</td>
    <td class="described"><a
      href="#id-selectors">ID
    selectors</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E:not(s)</td>
    <td class="meaning">an E element that does not match simple selector s</td>
    <td class="described"><a
      href="#negation">Negation
      pseudo-class</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E F</td>
    <td class="meaning">an F element descendant of an E element</td>
    <td class="described"><a
      href="#descendant-combinators">Descendant
      combinator</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E &gt; F</td>
    <td class="meaning">an F element child of an E element</td>
    <td class="described"><a
      href="#child-combinators">Child
      combinator</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E + F</td>
    <td class="meaning">an F element immediately preceded by an E element</td>
    <td class="described"><a
      href="#adjacent-sibling-combinators">Adjacent sibling combinator</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E ~ F</td>
    <td class="meaning">an F element preceded by an E element</td>
    <td class="described"><a
      href="#general-sibling-combinators">General sibling combinator</a></td>
    <td class="origin">3</td></tr></tbody></table>

<p>The meaning of each selector is derived from the table above by
prepending "matches" to the contents of each cell in the "Meaning"
column.</p>

<h2><a name=casesens>3. Case sensitivity</a></h2>

<p>The case sensitivity of document language element names, attribute
names, and attribute values in selectors depends on the document
language. For example, in HTML, element names are case-insensitive,
but in XML, they are case-sensitive.</p>

<h2><a name=selector-syntax>4. Selector syntax</a></h2>

<p>A <dfn><a name=selector>selector</a></dfn> is a chain of one
or more <a href="#sequence">sequences of simple selectors</a>
separated by <a href="#combinators">combinators</a>.</p>

<p>A <dfn><a name=sequence>sequence of simple selectors</a></dfn>
is a chain of <a href="#simple-selectors-dfn">simple selectors</a>
that are not separated by a <a href="#combinators">combinator</a>. It
always begins with a <a href="#type-selectors">type selector</a> or a
<a href="#universal-selector">universal selector</a>. No other type
selector or universal selector is allowed in the sequence.</p>

<p>A <dfn><a name=simple-selectors-dfn></a><a
href="#simple-selectors">simple selector</a></dfn> is either a <a
href="#type-selectors">type selector</a>, <a
href="#universal-selector">universal selector</a>, <a
href="#attribute-selectors">attribute selector</a>, <a
href="#class-html">class selector</a>, <a
href="#id-selectors">ID selector</a>, <a
href="#content-selectors">content selector</a>, or <a
href="#pseudo-classes">pseudo-class</a>. One <a
href="#pseudo-elements">pseudo-element</a> may be appended to the last
sequence of simple selectors.</p>

<p><dfn>Combinators</dfn> are: white space, &quot;greater-than
sign&quot; (U+003E, <code>&gt;</code>), &quot;plus sign&quot; (U+002B,
<code>+</code>) and &quot;tilde&quot; (U+007E, <code>~</code>).  White
space may appear between a combinator and the simple selectors around
it. <a name=whitespace></a>Only the characters "space" (U+0020), "tab"
(U+0009), "line feed" (U+000A), "carriage return" (U+000D), and "form
feed" (U+000C) can occur in white space. Other space-like characters,
such as "em-space" (U+2003) and "ideographic space" (U+3000), are
never part of white space.</p>

<p>The elements of a document tree that are represented by a selector
are the <dfn><a name=subject></a>subjects of the selector</dfn>. A
selector consisting of a single sequence of simple selectors
represents any element satisfying its requirements. Prepending another
sequence of simple selectors and a combinator to a sequence imposes
additional matching constraints, so the subjects of a selector are
always a subset of the elements represented by the last sequence of
simple selectors.</p>

<p>An empty selector, containing no sequence of simple selectors and
no pseudo-element, is an <a href="#Conformance">invalid
selector</a>.</p>

<h2><a name=grouping>5. Groups of selectors</a></h2>

<p>When several selectors share the same declarations, they may be
grouped into a comma-separated list. (A comma is U+002C.)</p>

<div class="example">
<p>CSS examples:</p>
<p>In this example, we condense three rules with identical
declarations into one. Thus,</p>
<pre>h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>
<p>is equivalent to:</p>
<pre>h1, h2, h3 { font-family: sans-serif }</pre>
</div>

<p><strong>Warning</strong>: the equivalence is true in this example
because all the selectors are valid selectors. If just one of these
selectors were invalid, the entire group of selectors would be
invalid. This would invalidate the rule for all three heading
elements, whereas in the former case only one of the three individual
heading rules would be invalidated.</p>

<h3><a name=pseudo-elements>7. Pseudo-elements</a></h3>

<p>Pseudo-elements create abstractions about the document tree beyond
those specified by the document language. For instance, document
languages do not offer mechanisms to access the first letter or first
line of an element's content. Pseudo-elements allow designers to refer
to this otherwise inaccessible information. Pseudo-elements may also
provide designers a way to refer to content that does not exist in the
source document (e.g., the <code>::before</code> and
<code>::after</code> pseudo-elements give access to generated
content).</p>

<p>A pseudo-element is made of two colons (<code>::</code>) followed
by the name of the pseudo-element.</p>

<p>This <code>::</code> notation is introduced by the current document
in order to establish a discrimination between pseudo-classes and
pseudo-elements.  For compatibility with existing style sheets, user
agents must also accept the previous one-colon notation for
pseudo-elements introduced in CSS levels 1 and 2 (namely,
<code>:first-line</code>, <code>:first-letter</code>,
<code>:before</code> and <code>:after</code>). This compatibility is
not allowed for the new pseudo-elements introduced in CSS level 3.</p>

<p>Only one pseudo-element may appear per selector, and if present it
must appear after the sequence of simple selectors that represents the
<a href="#subject">subjects</a> of the selector. <span class="note">A
future version of this specification may allow multiple
pesudo-elements per selector.</span></p>

<h4><a name=first-line>7.1. The ::first-line pseudo-element</a></h4>

<p>The <code>::first-line</code> pseudo-element describes the contents
of the first formatted line of an element.

<div class="example">
<p>CSS example:</p>
<pre>p::first-line { text-transform: uppercase }</pre>
<p>The above rule means "change the letters of the first line of every
paragraph to uppercase".</p>
</div>

<p>The selector <code>p::first-line</code> does not match any real
HTML element. It does match a pseudo-element that conforming user
agents will insert at the beginning of every paragraph.</p>

<p>Note that the length of the first line depends on a number of
factors, including the width of the page, the font size, etc.  Thus,
an ordinary HTML paragraph such as:</p>

<pre>
&lt;P&gt;This is a somewhat long HTML 
paragraph that will be broken into several 
lines. The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>the lines of which happen to be broken as follows:

<pre>
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag 
sequence. The other lines will be treated as 
ordinary lines in the paragraph.
</pre>

<p>This paragraph might be "rewritten" by user agents to include the
<em>fictional tag sequence</em> for <code>::first-line</code>. This
fictional tag sequence helps to show how properties are inherited.</p>

<pre>
&lt;P&gt;<b>&lt;P::first-line&gt;</b> This is a somewhat long HTML 
paragraph that <b>&lt;/P::first-line&gt;</b> will be broken into several
lines. The first line will be identified 
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>If a pseudo-element breaks up a real element, the desired effect
can often be described by a fictional tag sequence that closes and
then re-opens the element. Thus, if we mark up the previous paragraph
with a <code>span</code> element:</p>

<pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>the user agent could simulate start and end tags for
<code>span</code> when inserting the fictional tag sequence for
<code>::first-line</code>.

<pre>
&lt;P&gt;&lt;P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>In CSS, the <code>::first-line</code> pseudo-element can only be
attached to a block-level element, an inline-block, a table-caption,
or a table-cell.</p>

<p><a name="first-formatted-line"></a>The "first formatted line" of an
element may occur inside a
block-level descendant in the same flow (i.e., a block-level
descendant that is not positioned and not a float). E.g., the first
line of the <code>div</code> in <code>&lt;DIV>&lt;P>This
line...&lt;/P>&lt/DIV></code> is the first line of the <code>p</code> (assuming
that both <code>p</code> and <code>div</code> are block-level).

<p>The first line of a table-cell or inline-block cannot be the first
formatted line of an ancestor element. Thus, in <code>&lt;DIV&gt;&lt;P
STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
etcetera&lt;/DIV&gt;</code> the first formatted line of the
<code>div</code> is not the line "Hello".

<p class="note">Note that the first line of the <code>p</code> in this
fragment: <code>&lt;p&gt&lt;br&gt;First...</code> doesn't contain any
letters (assuming the default style for <code>br</code> in HTML
4). The word "First" is not on the first formatted line.

<p>A UA should act as if the fictional start tags of the
<code>::first-line</code> pseudo-elements were nested just inside the
innermost enclosing block-level element. (Since CSS1 and CSS2 were
silent on this case, authors should not rely on this behavior.) Here
is an example. The fictional tag sequence for</p>

<pre>
&lt;DIV>
  &lt;P>First paragraph&lt;/P>
  &lt;P>Second paragraph&lt;/P>
&lt;/DIV>
</pre>

<p>is</p>

<pre>
&lt;DIV>
  &lt;P>&lt;DIV::first-line>&lt;P::first-line>First paragraph&lt;/P::first-line>&lt;/DIV::first-line>&lt;/P>
  &lt;P>&lt;P::first-line>Second paragraph&lt;/P::first-line>&lt;/P>
&lt;/DIV>
</pre>

<p>The <code>::first-line</code> pseudo-element is similar to an
inline-level element, but with certain restrictions. In CSS, the
following properties apply to a <code>::first-line</code>
pseudo-element: font properties, color property, background
properties, 'word-spacing', 'letter-spacing', 'text-decoration',
'vertical-align', 'text-transform', 'line-height'. UAs may apply other
properties as well.</p>


<h4><a name=first-letter>7.2. The ::first-letter pseudo-element</a></h4>

<p>The <code>::first-letter</code> pseudo-element represents the first
letter of the first line of a block, if it is not preceded by any
other content (such as images or inline tables) on its line. The
::first-letter pseudo-element may be used for "initial caps" and "drop
caps", which are common typographical effects. This type of initial
letter is similar to an inline-level element if its 'float' property
is 'none'; otherwise, it is similar to a floated element.</p>

<p>In CSS, these are the properties that apply to <code>::first-letter</code>
pseudo-elements: font properties, 'text-decoration', 'text-transform',
'letter-spacing', 'word-spacing' (when appropriate), 'line-height',
'float', 'vertical-align' (only if 'float' is 'none'), margin
properties, padding properties, border properties, color property,
background properties.  UAs may apply other properties as well.  To
allow UAs to render a typographically correct drop cap or initial cap,
the UA may choose a line-height, width and height based on the shape
of the letter, unlike for normal elements.</p>

<div class="example">
<p>Example:</p>
<p>This example shows a possible rendering of an initial cap. Note
that the 'line-height' that is inherited by the <code>::first-letter</code>
pseudo-element is 1.1, but the UA in this example has computed the
height of the first letter differently, so that it doesn't cause any
unnecessary space between the first two lines. Also note that the
fictional start tag of the first letter is inside the <span>span</span>, and thus
the font weight of the first letter is normal, not bold as the <span>span</span>:
<pre>
p { line-height: 1.1 }
p::first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p>&lt;span>Het hemelsche&lt;/span> gerecht heeft zich ten lange lesten&lt;br>
Erbarremt over my en mijn benaeuwde vesten&lt;br>
En arme burgery, en op mijn volcx gebed&lt;br>
En dagelix geschrey de bange stad ontzet.
</pre>
<div class="figure">
<p><img src="" alt="Image illustrating the ::first-letter pseudo-element">
</div>
</div>

<div class="example">
<p>The following CSS will make a drop cap initial letter span about two lines:</p>

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P               { font-size: 12pt; line-height: 1.2 }
   P::first-letter { font-size: 200%; font-weight: bold; float: left }
   SPAN            { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>This example might be formatted as follows:</p>

<div class="figure">
<P><img src="" alt="Image illustrating the combined effect of the ::first-letter and ::first-line pseudo-elements"></p>
</div>

<p>The <span class="index-inst" title="fictional tag
sequence">fictional tag sequence</span> is:</p>

<pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P::first-letter&gt;
T
&lt;/P::first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

<p>Note that the <code>::first-letter</code> pseudo-element tags abut
the content (i.e., the initial character), while the ::first-line
pseudo-element start tag is inserted right after the start tag of the
block element.</p> </div>

<p>In order to achieve traditional drop caps formatting, user agents
may approximate font sizes, for example to align baselines. Also, the
glyph outline may be taken into account when formatting.</p>

<p>Punctuation (i.e, characters defined in Unicode in the "open" (Ps),
"close" (Pe), "initial" (Pi). "final" (Pf) and "other" (Po)
punctuation classes), that precedes or follows the first letter should
be included. <a href="#refsUNICODE">[UNICODE]</a></p>

<div class="figure">
<P><img src="" alt="Quotes that precede the
first letter should be included."></p>
</div>

<p>The <code>::first-letter</code> also applies if the first letter is
in fact a digit, e.g., the "6" in "67 million dollars is a lot of
money."</p>

<p>In CSS, the <code>::first-letter</code> pseudo-element applies to
block, list-item, table-cell, table-caption, and inline-block
elements. <span class="note">A future version of this specification
may allow this pesudo-element to apply to more element
types.</span></p>

<p>The <code>::first-letter</code> pseudo-element can be used with all
such elements that contain text, or that have a descendant in the same
flow that contains text. A UA should act as if the fictional start tag
of the ::first-letter pseudo-element is just before the first text of
the element, even if that first text is in a descendant.</p>

<div class="example">
<p>Example:</p>
<p>The fictional tag sequence for this HTMLfragment:
<pre>&lt;div>
&lt;p>The first text.</pre>
<p>is:
<pre>&lt;div>
&lt;p>&lt;div::first-letter>&lt;p::first-letter>T&lt;/...>&lt;/...>he first text.</pre>
</div>

<p>The first letter of a table-cell or inline-block cannot be the
first letter of an ancestor element. Thus, in <code>&lt;DIV&gt;&lt;P
STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
etcetera&lt;/DIV&gt;</code> the first letter of the <code>div</code> is not the
letter "H". In fact, the <code>div</code> doesn't have a first letter.

<p>The first letter must occur on the <a
href="#first-formatted-line">first formatted line.</a> For example, in
this fragment: <code>&lt;p&gt&lt;br&gt;First...</code> the first line
doesn't contain any letters and <code>::first-letter</code> doesn't
match anything (assuming the default style for <code>br</code> in HTML
4). In particular, it does not match the "F" of "First."

<p>In CSS, if an element is a list item ('display: list-item'), the
<code>::first-letter</code> applies to the first letter in the
principal box after the marker. UAs may ignore
<code>::first-letter</code> on list items with 'list-style-position:
inside'. If an element has <code>::before</code> or
<code>::after</code> content, the <code>::first-letter</code> applies
to the first letter of the element <em>including</em> that content.

<div class="example">
<p>Example:</p>
<p>After the rule 'p::before {content: "Note: "}', the selector
'p::first-letter' matches the "N" of "Note".</p>
</div>

<p>Some languages may have specific rules about how to treat certain
letter combinations. In Dutch, for example, if the letter combination
"ij" appears at the beginning of a word, both letters should be
considered within the <code>::first-letter</code> pseudo-element.

<p>If the letters that would form the ::first-letter are not in the
same element, such as "'T" in <code>&lt;p>'&lt;em>T...</code>, the UA
may create a ::first-letter pseudo-element from one of the elements,
both elements, or simply not create a pseudo-element.</p>

<p>Similarly, if the first letter(s) of the block are not at the start
of the line (for example due to bidirectional reordering), then the UA
need not create the pseudo-element(s).

<div class="example">
<p>Example:</p>
<p><a name="overlapping-example">The following example</a> illustrates
how overlapping pseudo-elements may interact.  The first letter of
each P element will be green with a font size of '24pt'. The rest of
the first formatted line will be 'blue' while the rest of the
paragraph will be 'red'.</p>

<pre>p { color: red; font-size: 12pt }
p::first-letter { color: green; font-size: 200% }
p::first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;</pre>

<p>Assuming that a line break will occur before the word "ends", the
<span class="index-inst" title="fictional tag sequence">fictional tag
sequence</span> for this fragment might be:</p>

<pre>&lt;P&gt;
&lt;P::first-line&gt;
&lt;P::first-letter&gt; 
S 
&lt;/P::first-letter&gt;ome text that 
&lt;/P::first-line&gt; 
ends up on two lines 
&lt;/P&gt;</pre>

<p>Note that the <code>::first-letter</code> element is inside the <code>::first-line</code>
element.  Properties set on <code>::first-line</code> are inherited by
<code>::first-letter</code>, but are overridden if the same property is set on
<code>::first-letter</code>.</p>
</div>


<h4><a name=UIfragments>7.3.</a> <a name=selection>The ::selection pseudo-element</a></h4>

<p>The <code>::selection</code> pseudo-element applies to the portion
of a document that has been highlighted by the user. This also
applies, for example, to selected text within an editable text
field. This pseudo-element should not be confused with the <code><a
href="#checked">:checked</a></code> pseudo-class (which used to be
named <code>:selected</code>)

<p>Although the <code>::selection</code> pseudo-element is dynamic in
nature, and is altered by user action, it is reasonable to expect that
when a UA re-renders to a static medium (such as a printed page, see
<a href="#refsCSS21">[CSS21]</a>) which was originally rendered to a
dynamic medium (like screen), the UA may wish to transfer the current
<code>::selection</code> state to that other medium, and have all the
appropriate formatting and rendering take effect as well. This is not
required &mdash; UAs may omit the <code>::selection</code>
pseudo-element for static media.

<p>These are the CSS properties that apply to <code>::selection</code>
pseudo-elements: color, background, cursor (optional), outline
(optional). The computed value of the 'background-image' property on
<code>::selection</code> may be ignored.


<h4><a name=gen-content>7.4. The ::before and ::after pseudo-elements</a></h4>

<p>The <code>::before</code> and <code>::after</code> pseudo-elements
can be used to describe generated content before or after an element's
content. They are explained in CSS 2.1 <a
href="#refsCSS21">[CSS21]</a>.</p>

<p>When the <code>::first-letter</code> and <code>::first-line</code>
pseudo-elements are combined with <code>::before</code> and
<code>::after</code>, they apply to the first letter or line of the
element including the inserted text.</p>

<h2><a name=combinators>8. Combinators</a></h2>

<h3><a name=descendant-combinators>8.1. Descendant combinator</a></h3>

<p>At times, authors may want selectors to describe an element that is
the descendant of another element in the document tree (e.g., "an
<code>EM</code> element that is contained within an <code>H1</code>
element"). Descendant combinators express such a relationship. A
descendant combinator is <a href="#whitespace">white space</a> that
separates two sequences of simple selectors.  A selector of the form
"<code>A B</code>" represents an element <code>B</code> that is an
arbitrary descendant of some ancestor element <code>A</code>.

<div class="example">
 <p>Examples:</p>
 <p>For example, consider the following selector:</p>
 <pre>h1 em</pre>
 <p>It represents an <code>em</code> element being the descendant of
 an <code>h1</code> element. It is a correct and valid, but partial,
 description of the following fragment:</p>
 <pre>&lt;h1&gt;This &lt;span class="myclass"&gt;headline
is &lt;em&gt;very&lt;/em&gt; important&lt;/span&gt;&lt;/h1&gt;</pre>
 <p>The following selector:</p>
 <pre>div * p</pre>
 <p>represents a <code>p</code> element that is a grandchild or later
 descendant of a <code>div</code> element. Note the whitespace on
 either side of the "*" is not part of the universal selector; the
 whitespace is a combinator indicating that the DIV must be the
 ancestor of some element, and that that element must be an ancestor
 of the P.</p>
 <p>The following selector, which combines descendant combinators and
 <a href="#attribute-selectors">attribute selectors</a>, represents an
 element that (1) has the <code>href</code> attribute set and (2) is
 inside a <code>p</code> that is itself inside a <code>div</code>:</p>
 <pre>div p *[href]</pre>
</div>

<h3><a name=child-combinators>8.2. Child combinators</a></h3>

<p>A <dfn>child combinator</dfn> describes a childhood relationship
between two elements. A child combinator is made of the
&quot;greater-than sign&quot; (<code>&gt;</code>) character and
separates two sequences of simple selectors.


<div class="example">
 <p>Examples:</p>
 <p>The following selector represents a <code>p</code> element that is
 child of <code>body</code>:</p>
 <pre>body &gt; p</pre>
 <p>The following example combines descendant combinators and child
 combinators.</p>
 <pre>div ol&gt;li p</pre>
 <p>It represents a <code>p</code> element that is a descendant of an
 <code>li</code> element; the <code>li</code> element must be the
 child of an <code>ol</code> element; the <code>ol</code> element must
 be a descendant of a <code>div</code>. Notice that the optional white
 space around the "&gt;" combinator has been left out.</p>
</div>

<p>For information on selecting the first child of an element, please
see the section on the <code><a
href="#structural-pseudos">:first-child</a></code> pseudo-class
above.</p>

<h3><a name=sibling-combinators>8.3. Sibling combinators</a></h3>

<p>There are two different sibling combinators: the adjacent sibling
combinator and the general sibling combinator. In both cases,
non-element nodes (e.g. text between elements) are ignored when
considering adjacency of elements.</p>

<h4><a name=adjacent-sibling-combinators>8.3.1. Adjacent sibling combinator</a></h4>

<p>The adjacent sibling combinator is made of the &quot;plus
sign&quot; (U+002B, <code>+</code>) character that separates two
sequences of simple selectors. The elements represented by the two
sequences share the same parent in the document tree and the element
represented by the first sequence immediately precedes the element
represented by the second one.</p>

<div class="example">
 <p>Examples:</p>
 <p>The following selector represents a <code>p</code> element
 immediately following a <code>math</code> element:</p>
 <pre>math + p</pre>
 <p>The following selector is conceptually similar to the one in the
 previous example, except that it adds an attribute selector &mdash; it
 adds a constraint to the <code>h1</code> element, that it must have
 <code>class="opener"</code>:</p>
 <pre>h1.opener + h2</pre>
</div>


<h4><a name=general-sibling-combinators>8.3.2. General sibling combinator</a></h4>

<p>The general sibling combinator is made of the &quot;tilde&quot;
(U+007E, <code>~</code>) character that separates two sequences of
simple selectors. The elements represented by the two sequences share
the same parent in the document tree and the element represented by
the first sequence precedes (not necessarily immediately) the element
represented by the second one.</p>

<div class="example">
 <p>Example:</p>
 <pre>h1 ~ pre</pre>
 <p>represents a <code>pre</code> element following an <code>h1</code>. It
 is a correct and valid, but partial, description of:</p>
 <pre>&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;</pre>
</div>

<h2><a name=specificity>9. Calculating a selector's specificity</a></h2>

<p>A selector's specificity is calculated as follows:</p>

<ul>
  <li>count the number of ID selectors in the selector (= a)</li>
  <li>count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= b)</li>
  <li>count the number of element names in the selector (= c)</li>
  <li>ignore pseudo-elements</li>
</ul>

<p>Selectors inside <a href="#negation">the negation pseudo-class</a>
are counted like any other, but the negation itself does not count as
a pseudo-class.</p>

<p>Concatenating the three numbers a-b-c (in a number system with a
large base) gives the specificity.</p>

<div class="example">
<p>Examples:</p>
<pre>*               /* a=0 b=0 c=0 -&gt; specificity =   0 */
LI              /* a=0 b=0 c=1 -&gt; specificity =   1 */
UL LI           /* a=0 b=0 c=2 -&gt; specificity =   2 */
UL OL+LI        /* a=0 b=0 c=3 -&gt; specificity =   3 */
H1 + *[REL=up]  /* a=0 b=1 c=1 -&gt; specificity =  11 */
UL OL LI.red    /* a=0 b=1 c=3 -&gt; specificity =  13 */
LI.red.level    /* a=0 b=2 c=1 -&gt; specificity =  21 */
#x34y           /* a=1 b=0 c=0 -&gt; specificity = 100 */
#s12:not(FOO)   /* a=1 b=0 c=1 -&gt; specificity = 101 */
</pre>
</div>

<p class="note"><strong>Note:</strong> the specificity of the styles
specified in an HTML <code>style</code> attribute is described in CSS
2.1. <a href="#refsCSS21">[CSS21]</a>.</p>

<h2><a name=downlevel>11. Namespaces and down-level clients</a></h2>

<p>An important issue is the interaction of CSS selectors with XML
documents in web clients that were produced prior to this
document. Unfortunately, due to the fact that namespaces must be
matched based on the URI which identifies the namespace, not the
namespace prefix, some mechanism is required to identify namespaces in
CSS by their URI as well. Without such a mechanism, it is impossible
to construct a CSS style sheet which will properly match selectors in
all cases against a random set of XML documents. However, given
complete knowledge of the XML document to which a style sheet is to be
applied, and a limited use of namespaces within the XML document, it
is possible to construct a style sheet in which selectors would match
elements and attributes correctly.</p>

<p>It should be noted that a down-level CSS client will (if it
properly conforms to CSS forward compatible parsing rules) ignore all
<code>@namespace</code> at-rules, as well as all style rules that make
use of namespace qualified element type or attribute selectors. The
syntax of delimiting namespace prefixes in CSS was deliberately chosen
so that down-level CSS clients would ignore the style rules rather
than possibly match them incorrectly.</p>

<p>The use of default namespaces in CSS makes it possible to write
element type selectors that will function in both namespace aware CSS
clients as well as down-level clients. It should be noted that
down-level clients may incorrectly match selectors against XML
elements in other namespaces.</p>

<p>The following are scenarios and examples in which it is possible to
construct style sheets which would function properly in web clients
that do not implement this proposal.</p>

<ol>
  <li>

   <p>The XML document does not use namespaces.</p>

   <ul>

    <li>In this case, it is obviously not necessary to declare or use
    namespaces in the style sheet. Standard CSS element type and
    attribute selectors will function adequately in a down-level
    client.</li>

    <li>In a CSS namespace aware client, the default behavior of
    element selectors matching without regard to namespace will
    function properly against all elements, since no namespaces are
    present. However, the use of specific element type selectors that
    match only elements that have no namespace ("<code>|name</code>")
    will guarantee that selectors will match only XML elements that do
    not have a declared namespace. </li>

   </ul>

  </li>

  <li>

   <p>The XML document defines a single, default namespace used
   throughout the document. No namespace prefixes are used in element
   names.</p>

   <ul>

    <li>In this case, a down-level client will function as if
    namespaces were not used in the XML document at all. Standard CSS
    element type and attribute selectors will match against all
    elements. </li>

   </ul>

  </li>

  <li>

   <p>The XML document does <b>not</b> use a default namespace, all
   namespace prefixes used are known to the style sheet author, and
   there is a direct mapping between namespace prefixes and namespace
   URIs. (A given prefix may only be mapped to one namespace URI
   throughout the XML document; there may be multiple prefixes mapped
   to the same URI).</p>

   <ul>

    <li>In this case, the down-level client will view and match
    element type and attribute selectors based on their fully
    qualified name, not the local part as outlined in the <a
    href="#typenmsp">Type selectors and Namespaces</a> section. CSS
    selectors may be declared using an escaped colon "<code>\:</code>"
    to describe the fully qualified names, e.g.
    "<code>html\:h1</code>" will match
    <code>&lt;html:h1&gt;</code>. Selectors using the qualified name
    will only match XML elements that use the same prefix. Other
    namespace prefixes used in the XML that are mapped to the same URI
    will not match as expected unless additional CSS style rules are
    declared for them.</li>

    <li>Note that selectors declared in this fashion will
    <em>only</em> match in down-level clients. A CSS namespace aware
    client will match element type and attribute selectors based on
    the name's local part. Selectors declared with the fully
    qualified name will not match (unless there is no namespace prefix
    in the fully qualified name).</li>

   </ul>

  </li>

 </ol>

<p>In other scenarios: when the namespace prefixes used in the XML are
not known in advance by the style sheet author; or a combination of
elements with no namespace are used in conjunction with elements using
a default namespace; or the same namespace prefix is mapped to
<em>different</em> namespace URIs within the same document, or in
different documents; it is impossible to construct a CSS style sheet
that will function properly against all elements in those documents,
unless, the style sheet is written using a namespace URI syntax (as
outlined in this document or similar) and the document is processed by
a CSS and XML namespace aware client.</p>

<h2><a name=profiling>12. Profiles</a></h2>

<p>Each specification using Selectors must define the subset of W3C
Selectors it allows and excludes, and describe the local meaning of
all the components of that subset.</p>

<p>Non normative examples:

<div class="profile">
<table class="tprofile">
  <tbody>
  <tr>
    <th class="title" colspan=2>Selectors profile</th></tr>
  <tr>
    <th>Specification</th>
    <td>CSS level 1</td></tr>
  <tr>
    <th>Accepts</th>
    <td>type selectors<br>class selectors<br>ID selectors<br>:link,
      :visited and :active pseudo-classes<br>descendant combinator
     <br>::first-line and ::first-letter pseudo-elements</td></tr>
  <tr>
    <th>Excludes</th>
    <td>
      
<p>universal selector<br>attribute selectors<br>:hover and :focus
      pseudo-classes<br>:target pseudo-class<br>:lang() pseudo-class<br>all UI
      element states pseudo-classes<br>all structural
      pseudo-classes<br>negation pseudo-class<br>all
      UI element fragments pseudo-elements<br>::before and ::after
      pseudo-elements<br>child combinators<br>sibling combinators
      
<p>namespaces</td></tr>
  <tr>
    <th>Extra constraints</th>
    <td>only one class selector allowed per sequence of simple
  selectors</td></tr></tbody></table><br><br>
<table class="tprofile">
  <tbody>
  <tr>
    <th class="title" colspan=2>Selectors profile</th></tr>
  <tr>
    <th>Specification</th>
    <td>CSS level 2</td></tr>
  <tr>
    <th>Accepts</th>
    <td>type selectors<br>universal selector<br>attribute presence and
      values selectors<br>class selectors<br>ID selectors<br>:link, :visited,
      :active, :hover, :focus, :lang() and :first-child pseudo-classes
     <br>descendant combinator<br>child combinator<br>adjacent sibling
      combinator<br>::first-line and ::first-letter pseudo-elements<br>::before
      and ::after pseudo-elements</td></tr>
  <tr>
    <th>Excludes</th>
    <td>
      
<p>content selectors<br>substring matching attribute
      selectors<br>:target pseudo-classes<br>all UI element
      states pseudo-classes<br>all structural pseudo-classes other
      than :first-child<br>negation pseudo-class<br>all UI element
      fragments pseudo-elements<br>general sibling combinators
      
<p>namespaces</td></tr>
  <tr>
    <th>Extra constraints</th>
    <td>more than one class selector per sequence of simple selectors (CSS1
      constraint) allowed</td></tr></tbody></table>

<p>In CSS, selectors express pattern matching rules that determine which style
rules apply to elements in the document tree. 

<p>The following selector (CSS level 2) will <b>match</b> all anchors <code>a</code>
with attribute <code>name</code> set inside a section 1 header <code>h1</code>: 
<pre>h1 a[name]</pre>

<p>All CSS declarations attached to such a selector are applied to elements
matching it. </div>

<div class="profile">
<table class="tprofile">
  <tbody>
  <tr>
    <th class="title" colspan=2>Selectors profile</th></tr>
  <tr>
    <th>Specification</th>
      <td>STTS 3</td>
    </tr>
  <tr>
    <th>Accepts</th>
    <td>
      
<p>type selectors<br>universal selectors<br>attribute selectors<br>class
      selectors<br>ID selectors<br>all structural pseudo-classes<br>
          all combinators
      
<p>namespaces</td></tr>
  <tr>
    <th>Excludes</th>
    <td>non-accepted pseudo-classes<br>pseudo-elements<br></td></tr>
  <tr>
    <th>Extra constraints</th>
    <td>some selectors and combinators are not allowed in fragment
      descriptions on the right side of STTS declarations.</td></tr></tbody></table>
  
<p>Selectors can be used in STTS 3 in two different
    manners: 
<ol>
  <li>a selection mechanism equivalent to CSS selection mechanism: declarations
  attached to a given selector are applied to elements matching that selector,
  <li>fragment descriptions that appear on the right side of declarations.
</li></ol></div>

