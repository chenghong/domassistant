 <div class=head><p><a href="http://www.w3.org/"><img height=48 alt=W3C src=""width=72></a><h1 id=title>Selectors</h1><h2>W3C Working Draft 15 December 2005</h2><dl><dt>This version:<dd><a href="http://www.w3.org/TR/2005/WD-css3-selectors-20051215"> http://www.w3.org/TR/2005/WD-css3-selectors-20051215</a><dt>Latest version:<dd><a href="http://www.w3.org/TR/css3-selectors"> http://www.w3.org/TR/css3-selectors</a><dt>Previous version:<dd><a href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113"> http://www.w3.org/TR/2001/CR-css3-selectors-20011113</a><dt><a name=editors-list></a>Editors:<dd class=vcard><span class=fn>Daniel Glazman</span> (Invited Expert)<dd class=vcard><a lang=tr class="url fn"href="http://www.tantek.com/">Tantek &Ccedil;elik</a> (Invited Expert)<dd class=vcard><a href="mailto:ian@hixie.ch"class="url fn">Ian Hickson</a> (<span class=company><a href="http://www.google.com/">Google</a></span>)<dd class=vcard><span class=fn>Peter Linss</span> (former editor, <span class=company><a href="http://www.netscape.com/">Netscape/AOL</a></span>)<dd class=vcard><span class=fn>John Williams</span> (former editor, <span class=company><a href="http://www.quark.com/">Quark, Inc.</a></span>)</dl><p class=copyright><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright"> Copyright</a> &copy; 2005 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>, <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.<hr title="Separator for header"></div><h2><a name=abstract></a>Abstract</h2><p><em>Selectors</em> are patterns that match against elements in a tree. Selectors have been optimized for use with HTML and XML, and are designed to be usable in performance-critical code.<p><acronym title="Cascading Style Sheets">CSS</acronym> (Cascading Style Sheets) is a language for describing the rendering of <acronym title="Hypertext Markup Language">HTML</acronym> and <acronym title="Extensible Markup Language">XML</acronym> documents on screen, on paper, in speech, etc. CSS uses Selectors for binding style properties to elements in the document. This document describes extensions to the selectors defined in CSS level 2. These extended selectors will be used by CSS level 3.<p>Selectors define the following function:<pre>expression &#x2217; element &rarr; boolean</pre><p>That is, given an element and a selector, this specification defines whether that element matches the selector.<p>These expressions can also be used, for instance, to select a set of elements, or a single element from a set of elements, by evaluating the expression across all the elements in a subtree. <acronym title="Simple Tree Transformation Sheets">STTS</acronym> (Simple Tree Transformation Sheets), a language for transforming XML trees, uses this mechanism. <a href="#refsSTTS">[STTS]</a><h2><a name=status></a>Status of this document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index at http://www.w3.org/TR/.</a></em><p>This document describes the selectors that already exist in <a href="#refsCSS1"><abbr title="CSS level 1">CSS1</abbr></a> and <a href="#refsCSS21"><abbr title="CSS level 2">CSS2</abbr></a>, and also proposes new selectors for <abbr title="CSS level 3">CSS3</abbr> and other languages that may need them.<p>The CSS Working Group doesn't expect that all implementations of CSS3 will have to implement all selectors. Instead, there will probably be a small number of variants of CSS3, called profiles. For example, it may be that only a profile for interactive user agents will include all of the selectors.<p>This specification is a last call working draft for the the <a href="http://www.w3.org/Style/CSS/members">CSS Working Group</a> (<a href="/Style/">Style Activity</a>). This document is a revision of the <a href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/">Candidate Recommendation dated 2001 November 13</a>, and has incorporated implementation feedback received in the past few years. It is expected that this last call will proceed straight to Proposed Recommendation stage since it is believed that interoperability will be demonstrable.<p>All persons are encouraged to review and implement this specification and return comments to the (<a href="http://lists.w3.org/Archives/Public/www-style/">archived</a>) public mailing list <a href="http://www.w3.org/Mail/Lists.html#www-style">www-style</a> (see <a href="http://www.w3.org/Mail/Request">instructions</a>). W3C Members can also send comments directly to the CSS Working Group. The deadline for comments is 14 January 2006.<p>This is still a draft document and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to cite a W3C Working Draft as other than &quot;work in progress&quot;.<p>This document may be available in <a href="http://www.w3.org/Style/css3-selectors-updates/translations">translation</a>. The English version of this specification is the only normative version. <div class=subtoc><h2><a name=contents>Table of contents</a></h2><ul class=toc><li class=tocline2><a href="#context">1. Introduction</a><ul><li><a href="#dependencies">1.1. Dependencies</a><li><a href="#terminology">1.2. Terminology</a><li><a href="#changesFromCSS2">1.3. Changes from CSS2</a></ul><li class=tocline2><a href="#selectors">2. Selectors</a><li class=tocline2><a href="#casesens">3. Case sensitivity</a><li class=tocline2><a href="#selector-syntax">4. Selector syntax</a><li class=tocline2><a href="#grouping">5. Groups of selectors</a><li class=tocline2><a href="#simple-selectors">6. Simple selectors</a><ul class=toc><li class=tocline3><a href="#type-selectors">6.1. Type selectors</a><ul class=toc><li class=tocline4><a href="#typenmsp">6.1.1. Type selectors and namespaces</a></ul><li class=tocline3><a href="#universal-selector">6.2. Universal selector</a><ul><li><a href="#univnmsp">6.2.1. Universal selector and namespaces</a></ul><li class=tocline3><a href="#attribute-selectors">6.3. Attribute selectors</a><ul class=toc><li class=tocline4><a href="#attribute-representation">6.3.1. Representation of attributes and attributes values</a><li><a href="#attribute-substrings">6.3.2. Substring matching attribute selectors</a><li class=tocline4><a href="#attrnmsp">6.3.3. Attribute selectors and namespaces</a><li class=tocline4><a href="#def-values">6.3.4. Default attribute values in DTDs</a></ul><li class=tocline3><a href="#class-html">6.4. Class selectors</a><li class=tocline3><a href="#id-selectors">6.5. ID selectors</a><li class=tocline3><a href="#pseudo-classes">6.6. Pseudo-classes</a><ul class=toc><li class=tocline4><a href="#dynamic-pseudos">6.6.1. Dynamic pseudo-classes</a><li class=tocline4><a href="#target-pseudo">6.6.2. The :target pseudo-class</a><li class=tocline4><a href="#lang-pseudo">6.6.3. The :lang() pseudo-class</a><li class=tocline4><a href="#UIstates">6.6.4. UI element states pseudo-classes</a><li class=tocline4><a href="#structural-pseudos">6.6.5. Structural pseudo-classes</a><ul><li><a href="#root-pseudo">:root pseudo-class</a><li><a href="#nth-child-pseudo">:nth-child() pseudo-class</a><li><a href="#nth-last-child-pseudo">:nth-last-child()</a><li><a href="#nth-of-type-pseudo">:nth-of-type() pseudo-class</a><li><a href="#nth-last-of-type-pseudo">:nth-last-of-type()</a><li><a href="#first-child-pseudo">:first-child pseudo-class</a><li><a href="#last-child-pseudo">:last-child pseudo-class</a><li><a href="#first-of-type-pseudo">:first-of-type pseudo-class</a><li><a href="#last-of-type-pseudo">:last-of-type pseudo-class</a><li><a href="#only-child-pseudo">:only-child pseudo-class</a><li><a href="#only-of-type-pseudo">:only-of-type pseudo-class</a><li><a href="#empty-pseudo">:empty pseudo-class</a></ul><li class=tocline4><a href="#negation">6.6.7. The negation pseudo-class</a></ul></ul><li><a href="#pseudo-elements">7. Pseudo-elements</a><ul><li><a href="#first-line">7.1. The ::first-line pseudo-element</a><li><a href="#first-letter">7.2. The ::first-letter pseudo-element</a><li><a href="#UIfragments">7.3. The ::selection pseudo-element</a><li><a href="#gen-content">7.4. The ::before and ::after pseudo-elements</a></ul><li class=tocline2><a href="#combinators">8. Combinators</a><ul class=toc><li class=tocline3><a href="#descendant-combinators">8.1. Descendant combinators</a><li class=tocline3><a href="#child-combinators">8.2. Child combinators</a><li class=tocline3><a href="#sibling-combinators">8.3. Sibling combinators</a><ul class=toc><li class=tocline4><a href="#adjacent-sibling-combinators">8.3.1. Adjacent sibling combinator</a><li class=tocline4><a href="#general-sibling-combinators">8.3.2. General sibling combinator</a></ul></ul><li class=tocline2><a href="#specificity">9. Calculating a selector's specificity</a><li class=tocline2><a href="#w3cselgrammar">10. The grammar of Selectors</a><ul class=toc><li class=tocline3><a href="#grammar">10.1. Grammar</a><li class=tocline3><a href="#lex">10.2. Lexical scanner</a></ul><li class=tocline2><a href="#downlevel">11. Namespaces and down-level clients</a><li class=tocline2><a href="#profiling">12. Profiles</a><li><a href="#Conformance">13. Conformance and requirements</a><li><a href="#Tests">14. Tests</a><li><a href="#ACKS">15. Acknowledgements</a><li class=tocline2><a href="#references">16. References</a></ul></div><h2><a name=context>1. Introduction</a></h2><h3><a name=dependencies></a>1.1. Dependencies</h3><p>Some features of this specification are specific to CSS, or have particular limitations or rules specific to CSS. In this specification, these have been described in terms of CSS2.1. <a href="#refsCSS21">[CSS21]</a><h3><a name=terminology></a>1.2. Terminology</h3><p>All of the text of this specification is normative except examples, notes, and sections explicitly marked as non-normative.<h3><a name=changesFromCSS2></a>1.3. Changes from CSS2</h3><p><em>This section is non-normative.</em><p>The main differences between the selectors in CSS2 and those in Selectors are:<ul><li>the list of basic definitions (selector, group of selectors, simple selector, etc.) has been changed; in particular, what was referred to in CSS2 as a simple selector is now called a sequence of simple selectors, and the term "simple selector" is now used for the components of this sequence<li>an optional namespace component is now allowed in type element selectors, the universal selector and attribute selectors<li>a <a href="#general-sibling-combinators">new combinator</a> has been introduced<li>new simple selectors including substring matching attribute selectors, and new pseudo-classes<li>new pseudo-elements, and introduction of the "::" convention for pseudo-elements<li>the grammar has been rewritten<li>profiles to be added to specifications integrating Selectors and defining the set of selectors which is actually supported by each specification<li>Selectors are now a CSS3 Module and an independent specification; other specifications can now refer to this document independently of CSS<li>the specification now has its own test suite</ul><h2><a name=selectors></a>2. Selectors</h2><p><em>This section is non-normative, as it merely summarizes the following sections.</em><p>A Selector represents a structure. This structure can be used as a condition (e.g. in a CSS rule) that determines which elements a selector matches in the document tree, or as a flat description of the HTML or XML fragment corresponding to that structure.<p>Selectors may range from simple element names to rich contextual representations.<p>The following table summarizes the Selector syntax:<table class=selectorsReview><thead><tr><th class=pattern>Pattern<th class=meaning>Meaning<th class=described>Described in section<th class=origin>First defined in CSS level<tbody><tr><td class=pattern>*<td class=meaning>any element<td class=described><a href="#universal-selector">Universal selector</a><td class=origin>2<tr><td class=pattern>E<td class=meaning>an element of type E<td class=described><a href="#type-selectors">Type selector</a><td class=origin>1<tr><td class=pattern>E[foo]<td class=meaning>an E element with a "foo" attribute<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>2<tr><td class=pattern>E[foo="bar"]<td class=meaning>an E element whose "foo" attribute value is exactly equal to "bar"<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>2<tr><td class=pattern>E[foo~="bar"]<td class=meaning>an E element whose "foo" attribute value is a list of space-separated values, one of which is exactly equal to "bar"<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>2<tr><td class=pattern>E[foo^="bar"]<td class=meaning>an E element whose "foo" attribute value begins exactly with the string "bar"<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>3<tr><td class=pattern>E[foo$="bar"]<td class=meaning>an E element whose "foo" attribute value ends exactly with the string "bar"<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>3<tr><td class=pattern>E[foo*="bar"]<td class=meaning>an E element whose "foo" attribute value contains the substring "bar"<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>3<tr><td class=pattern>E[hreflang|="en"]<td class=meaning>an E element whose "hreflang" attribute has a hyphen-separated list of values beginning (from the left) with "en"<td class=described><a href="#attribute-selectors">Attribute selectors</a><td class=origin>2<tr><td class=pattern>E:root<td class=meaning>an E element, root of the document<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:nth-child(n)<td class=meaning>an E element, the n-th child of its parent<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:nth-last-child(n)<td class=meaning>an E element, the n-th child of its parent, counting from the last one<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:nth-of-type(n)<td class=meaning>an E element, the n-th sibling of its type<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:nth-last-of-type(n)<td class=meaning>an E element, the n-th sibling of its type, counting from the last one<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:first-child<td class=meaning>an E element, first child of its parent<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>2<tr><td class=pattern>E:last-child<td class=meaning>an E element, last child of its parent<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:first-of-type<td class=meaning>an E element, first sibling of its type<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:last-of-type<td class=meaning>an E element, last sibling of its type<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:only-child<td class=meaning>an E element, only child of its parent<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:only-of-type<td class=meaning>an E element, only sibling of its type<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:empty<td class=meaning>an E element that has no children (including text nodes)<td class=described><a href="#structural-pseudos">Structural pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:link<br>E:visited<td class=meaning>an E element being the source anchor of a hyperlink of which the target is not yet visited (:link) or already visited (:visited)<td class=described><a href="#link">The link pseudo-classes</a><td class=origin>1<tr><td class=pattern>E:active<br>E:hover<br>E:focus<td class=meaning>an E element during certain user actions<td class=described><a href="#useraction-pseudos">The user action pseudo-classes</a><td class=origin>1 and 2<tr><td class=pattern>E:target<td class=meaning>an E element being the target of the referring URI<td class=described><a href="#target-pseudo">The target pseudo-class</a><td class=origin>3<tr><td class=pattern>E:lang(fr)<td class=meaning>an element of type E in language "fr" (the document language specifies how language is determined)<td class=described><a href="#lang-pseudo">The :lang() pseudo-class</a><td class=origin>2<tr><td class=pattern>E:enabled<br>E:disabled<td class=meaning>a user interface element E which is enabled or disabled<td class=described><a href="#UIstates">The UI element states pseudo-classes</a><td class=origin>3<tr><td class=pattern>E:checked<td class=meaning>a user interface element E which is checked (for instance a radio-button or checkbox)<td class=described><a href="#UIstates">The UI element states pseudo-classes</a><td class=origin>3<tr><td class=pattern>E::first-line<td class=meaning>the first formatted line of an E element<td class=described><a href="#first-line">The ::first-line pseudo-element</a><td class=origin>1<tr><td class=pattern>E::first-letter<td class=meaning>the first formatted letter of an E element<td class=described><a href="#first-letter">The ::first-letter pseudo-element</a><td class=origin>1<tr><td class=pattern>E::selection<td class=meaning>the portion of an E element that is currently selected/highlighted by the user<td class=described><a href="#UIfragments">The UI element fragments pseudo-elements</a><td class=origin>3<tr><td class=pattern>E::before<td class=meaning>generated content before an E element<td class=described><a href="#gen-content">The ::before pseudo-element</a><td class=origin>2<tr><td class=pattern>E::after<td class=meaning>generated content after an E element<td class=described><a href="#gen-content">The ::after pseudo-element</a><td class=origin>2<tr><td class=pattern>E.warning<td class=meaning>an E element whose class is "warning" (the document language specifies how class is determined).<td class=described><a href="#class-html">Class selectors</a><td class=origin>1<tr><td class=pattern>E#myid<td class=meaning>an E element with ID equal to "myid".<td class=described><a href="#id-selectors">ID selectors</a><td class=origin>1<tr><td class=pattern>E:not(s)<td class=meaning>an E element that does not match simple selector s<td class=described><a href="#negation">Negation pseudo-class</a><td class=origin>3<tr><td class=pattern>E F<td class=meaning>an F element descendant of an E element<td class=described><a href="#descendant-combinators">Descendant combinator</a><td class=origin>1<tr><td class=pattern>E &gt; F<td class=meaning>an F element child of an E element<td class=described><a href="#child-combinators">Child combinator</a><td class=origin>2<tr><td class=pattern>E + F<td class=meaning>an F element immediately preceded by an E element<td class=described><a href="#adjacent-sibling-combinators">Adjacent sibling combinator</a><td class=origin>2<tr><td class=pattern>E ~ F<td class=meaning>an F element preceded by an E element<td class=described><a href="#general-sibling-combinators">General sibling combinator</a><td class=origin>3</tbody></table><p>The meaning of each selector is derived from the table above by prepending "matches" to the contents of each cell in the "Meaning" column.<h2><a name=casesens>3. Case sensitivity</a></h2><p>The case sensitivity of document language element names, attribute names, and attribute values in selectors depends on the document language. For example, in HTML, element names are case-insensitive, but in XML, they are case-sensitive.<h2><a name=selector-syntax>4. Selector syntax</a></h2><p>A <dfn><a name=selector>selector</a></dfn> is a chain of one or more <a href="#sequence">sequences of simple selectors</a> separated by <a href="#combinators">combinators</a>.<p>A <dfn><a name=sequence>sequence of simple selectors</a></dfn> is a chain of <a href="#simple-selectors-dfn">simple selectors</a> that are not separated by a <a href="#combinators">combinator</a>. It always begins with a <a href="#type-selectors">type selector</a> or a <a href="#universal-selector">universal selector</a>. No other type selector or universal selector is allowed in the sequence.<p>A <dfn><a name=simple-selectors-dfn></a><a href="#simple-selectors">simple selector</a></dfn> is either a <a href="#type-selectors">type selector</a>, <a href="#universal-selector">universal selector</a>, <a href="#attribute-selectors">attribute selector</a>, <a href="#class-html">class selector</a>, <a href="#id-selectors">ID selector</a>, <a href="#content-selectors">content selector</a>, or <a href="#pseudo-classes">pseudo-class</a>. One <a href="#pseudo-elements">pseudo-element</a> may be appended to the last sequence of simple selectors.<p><dfn>Combinators</dfn> are: white space, &quot;greater-than sign&quot; (U+003E, <code>&gt;</code>), &quot;plus sign&quot; (U+002B, <code>+</code>) and &quot;tilde&quot; (U+007E, <code>~</code>). White space may appear between a combinator and the simple selectors around it. <a name=whitespace></a>Only the characters "space" (U+0020), "tab" (U+0009), "line feed" (U+000A), "carriage return" (U+000D), and "form feed" (U+000C) can occur in white space. Other space-like characters, such as "em-space" (U+2003) and "ideographic space" (U+3000), are never part of white space.<p>The elements of a document tree that are represented by a selector are the <dfn><a name=subject></a>subjects of the selector</dfn>. A selector consisting of a single sequence of simple selectors represents any element satisfying its requirements. Prepending another sequence of simple selectors and a combinator to a sequence imposes additional matching constraints, so the subjects of a selector are always a subset of the elements represented by the last sequence of simple selectors.<p>An empty selector, containing no sequence of simple selectors and no pseudo-element, is an <a href="#Conformance">invalid selector</a>.<h2><a name=grouping>5. Groups of selectors</a></h2><p>When several selectors share the same declarations, they may be grouped into a comma-separated list. (A comma is U+002C.) <div class=example><p>CSS examples:<p>In this example, we condense three rules with identical declarations into one. Thus,<pre>h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre><p>is equivalent to:<pre>h1, h2, h3 { font-family: sans-serif }</pre></div><p><strong>Warning</strong>: the equivalence is true in this example because all the selectors are valid selectors. If just one of these selectors were invalid, the entire group of selectors would be invalid. This would invalidate the rule for all three heading elements, whereas in the former case only one of the three individual heading rules would be invalidated.<h2><a name=simple-selectors>6. Simple selectors</a></h2><h3><a name=type-selectors>6.1. Type selector</a></h3><p>A <dfn>type selector</dfn> is the name of a document language element type. A type selector represents an instance of the element type in the document tree. <div class=example><p>Example:<p>The following selector represents an <code>h1</code> element in the document tree:<pre>h1</pre></div><h4><a name=typenmsp>6.1.1. Type selectors and namespaces</a></h4><p>Type selectors allow an optional namespace (<a href="#refsXMLNAMES">[XMLNAMES]</a>) component. A namespace prefix that has been previously declared may be prepended to the element name separated by the namespace separator &quot;vertical bar&quot; (U+007C, <code>|</code>).<p>The namespace component may be left empty to indicate that the selector is only to represent elements with no declared namespace.<p>An asterisk may be used for the namespace prefix, indicating that the selector represents elements in any namespace (including elements with no namespace).<p>Element type selectors that have no namespace component (no namespace separator), represent elements without regard to the element's namespace (equivalent to "<code>*|</code>") unless a default namespace has been declared. If a default namespace has been declared, the selector will represent only elements in the default namespace.<p>A type selector containing a namespace prefix that has not been previously declared is an <a href="#Conformance">invalid</a> selector. The mechanism for declaring a namespace prefix is left up to the language implementing Selectors. In CSS, such a mechanism is defined in the General Syntax module.<p>In a namespace-aware client, element type selectors will only match against the <a href="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a> of the element's <a href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">qualified name</a>. See <a href="#downlevel">below</a> for notes about matching behaviors in down-level clients.<p>In summary:<dl><dt><code>ns|E</code><dd>elements with name E in namespace ns<dt><code>*|E</code><dd>elements with name E in any namespace, including those without any declared namespace<dt><code>|E</code><dd>elements with name E without any declared namespace<dt><code>E</code><dd>if no default namespace has been specified, this is equivalent to *|E. Otherwise it is equivalent to ns|E where ns is the default namespace.</dl><div class=example><p>CSS examples:<pre>@namespace foo url(http://www.example.com);
 foo|h1 { color: blue }
 foo|* { color: yellow }
 |h1 { color: red }
 *|h1 { color: green }
 h1 { color: green }</pre><p>The first rule will match only <code>h1</code> elements in the "http://www.example.com" namespace.<p>The second rule will match all elements in the "http://www.example.com" namespace.<p>The third rule will match only <code>h1</code> elements without any declared namespace.<p>The fourth rule will match <code>h1</code> elements in any namespace (including those without any declared namespace).<p>The last rule is equivalent to the fourth rule because no default namespace has been defined. </div><h3><a name=universal-selector>6.2. Universal selector</a></h3><p>The <dfn>universal selector</dfn>, written &quot;asterisk&quot; (<code>*</code>), represents the qualified name of any element type. It represents any single element in the document tree in any namespace (including those without any declared namespace) if no default namespace has been specified. If a default namespace has been specified, see <a href="#univnmsp">Universal selector and Namespaces</a> below.<p>If the universal selector is not the only component of a sequence of simple selectors, the <code>*</code> may be omitted. <div class=example><p>Examples:<ul><li><code>*[hreflang|=en]</code> and <code>[hreflang|=en]</code> are equivalent,<li><code>*.warning</code> and <code>.warning</code> are equivalent,<li><code>*#myid</code> and <code>#myid</code> are equivalent.</ul></div><p class=note><strong>Note:</strong> it is recommended that the <code>*</code>, representing the universal selector, not be omitted.<h4><a name=univnmsp>6.2.1. Universal selector and namespaces</a></h4><p>The universal selector allows an optional namespace component. It is used as follows:<dl><dt><code>ns|*</code><dd>all elements in namespace ns<dt><code>*|*</code><dd>all elements<dt><code>|*</code><dd>all elements without any declared namespace<dt><code>*</code><dd>if no default namespace has been specified, this is equivalent to *|*. Otherwise it is equivalent to ns|* where ns is the default namespace.</dl><p>A universal selector containing a namespace prefix that has not been previously declared is an <a href="#Conformance">invalid</a> selector. The mechanism for declaring a namespace prefix is left up to the language implementing Selectors. In CSS, such a mechanism is defined in the General Syntax module.<h3><a name=attribute-selectors>6.3. Attribute selectors</a></h3><p>Selectors allow the representation of an element's attributes. When a selector is used as an expression to match against an element, attribute selectors must be considered to match an element if that element has an attribute that matches the attribute represented by the attribute selector.<h4><a name=attribute-representation>6.3.1. Attribute presence and values selectors</a></h4><p>CSS2 introduced four attribute selectors:<dl><dt><code>[att]</code><dd>Represents an element with the <code>att</code> attribute, whatever the value of the attribute.<dt><code>[att=val]</code><dd>Represents an element with the <code>att</code> attribute whose value is exactly "val".<dt><code>[att~=val]</code><dd>Represents an element with the <code>att</code> attribute whose value is a <a href="#whitespace">whitespace</a>-separated list of words, one of which is exactly "val". If "val" contains whitespace, it will never represent anything (since the words are <em>separated</em> by spaces).<dt><code>[att|=val]</code><dd>Represents an element with the <code>att</code> attribute, its value either being exactly "val" or beginning with "val" immediately followed by "-" (U+002D). This is primarily intended to allow language subcode matches (e.g., the <code>hreflang</code> attribute on the <code>link</code> element in HTML) as described in RFC 3066 (<a href="#refsRFC3066">[RFC3066]</a>). For <code>lang</code> (or <code>xml:lang</code>) language subcode matching, please see <a href="#lang-pseudo">the <code>:lang</code> pseudo-class</a>.</dl><p>Attribute values must be identifiers or strings. The case-sensitivity of attribute names and values in selectors depends on the document language. <div class=example><p>Examples:<p>The following attribute selector represents an <code>h1</code> element that carries the <code>title</code> attribute, whatever its value:<pre>h1[title]</pre><p>In the following example, the selector represents a <code>span</code> element whose <code>class</code> attribute has exactly the value "example":<pre>span[class="example"]</pre><p>Multiple attribute selectors can be used to represent several attributes of an element, or several conditions on the same attribute. Here, the selector represents a <code>span</code> element whose <code>hello</code> attribute has exactly the value "Cleveland" and whose <code>goodbye</code> attribute has exactly the value "Columbus":<pre>span[hello="Cleveland"][goodbye="Columbus"]</pre><p>The following selectors illustrate the differences between "=" and "~=". The first selector will represent, for example, the value "copyright copyleft copyeditor" on a <code>rel</code> attribute. The second selector will only represent an <code>a</code> element with an <code>href</code> attribute having the exact value "http://www.w3.org/".<pre>a[rel~="copyright"]
a[href="http://www.w3.org/"]</pre><p>The following selector represents a <code>link</code> element whose <code>hreflang</code> attribute is exactly "fr".<pre>link[hreflang=fr]</pre><p>The following selector represents a <code>link</code> element for which the values of the <code>hreflang</code> attribute begins with "en", including "en", "en-US", and "en-cockney":<pre>link[hreflang|="en"]</pre><p>Similarly, the following selectors represents a <code>DIALOGUE</code> element whenever it has one of two different values for an attribute <code>character</code>:<pre>DIALOGUE[character=romeo]
DIALOGUE[character=juliet]</pre></div><h4><a name=attribute-substrings></a>6.3.2. Substring matching attribute selectors</h4><p>Three additional attribute selectors are provided for matching substrings in the value of an attribute:<dl><dt><code>[att^=val]</code><dd>Represents an element with the <code>att</code> attribute whose value begins with the prefix "val".<dt><code>[att$=val]</code><dd>Represents an element with the <code>att</code> attribute whose value ends with the suffix "val".<dt><code>[att*=val]</code><dd>Represents an element with the <code>att</code> attribute whose value contains at least one instance of the substring "val".</dl><p>Attribute values must be identifiers or strings. The case-sensitivity of attribute names in selectors depends on the document language. <div class=example><p>Examples:<p>The following selector represents an HTML <code>object</code>, referencing an image:<pre>object[type^="image/"]</pre><p>The following selector represents an HTML anchor <code>a</code> with an <code>href</code> attribute whose value ends with ".html".<pre>a[href$=".html"]</pre><p>The following selector represents an HTML paragraph with a <code>title</code> attribute whose value contains the substring "hello"<pre>p[title*="hello"]</pre></div><h4><a name=attrnmsp>6.3.3. Attribute selectors and namespaces</a></h4><p>Attribute selectors allow an optional namespace component to the attribute name. A namespace prefix that has been previously declared may be prepended to the attribute name separated by the namespace separator &quot;vertical bar&quot; (<code>|</code>). In keeping with the Namespaces in the XML recommendation, default namespaces do not apply to attributes, therefore attribute selectors without a namespace component apply only to attributes that have no declared namespace (equivalent to "<code>|attr</code>"). An asterisk may be used for the namespace prefix indicating that the selector is to match all attribute names without regard to the attribute's namespace.<p>An attribute selector with an attribute name containing a namespace prefix that has not been previously declared is an <a href="#Conformance">invalid</a> selector. The mechanism for declaring a namespace prefix is left up to the language implementing Selectors. In CSS, such a mechanism is defined in the General Syntax module. <div class=example><p>CSS examples:<pre>@namespace foo "http://www.example.com";
[foo|att=val] { color: blue }
[*|att] { color: yellow }
[|att] { color: green }
[att] { color: green }</pre><p>The first rule will match only elements with the attribute <code>att</code> in the "http://www.example.com" namespace with the value "val".<p>The second rule will match only elements with the attribute <code>att</code> regardless of the namespace of the attribute (including no declared namespace).<p>The last two rules are equivalent and will match only elements with the attribute <code>att</code> where the attribute is not declared to be in a namespace. </div><h4><a name=general-sibling-combinators>8.3.2. General sibling combinator</a></h4><p>The general sibling combinator is made of the &quot;tilde&quot; (U+007E, <code>~</code>) character that separates two sequences of simple selectors. The elements represented by the two sequences share the same parent in the document tree and the element represented by the first sequence precedes (not necessarily immediately) the element represented by the second one. <div class=example><p>Example:<pre>h1 ~ pre</pre><p>represents a <code>pre</code> element following an <code>h1</code>. It is a correct and valid, but partial, description of:<pre>&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;</pre></div><h2><a name=specificity>9. Calculating a selector's specificity</a></h2><p>A selector's specificity is calculated as follows:<ul><li>count the number of ID selectors in the selector (= a)<li>count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= b)<li>count the number of element names in the selector (= c)<li>ignore pseudo-elements</ul><p>Selectors inside <a href="#negation">the negation pseudo-class</a> are counted like any other, but the negation itself does not count as a pseudo-class.<p>Concatenating the three numbers a-b-c (in a number system with a large base) gives the specificity. <div class=example><p>Examples:<pre>*               /* a=0 b=0 c=0 -&gt; specificity =   0 */
LI              /* a=0 b=0 c=1 -&gt; specificity =   1 */
UL LI           /* a=0 b=0 c=2 -&gt; specificity =   2 */
UL OL+LI        /* a=0 b=0 c=3 -&gt; specificity =   3 */
H1 + *[REL=up]  /* a=0 b=1 c=1 -&gt; specificity =  11 */
UL OL LI.red    /* a=0 b=1 c=3 -&gt; specificity =  13 */
LI.red.level    /* a=0 b=2 c=1 -&gt; specificity =  21 */
#x34y           /* a=1 b=0 c=0 -&gt; specificity = 100 */
#s12:not(FOO)   /* a=1 b=0 c=1 -&gt; specificity = 101 */
</pre></div><p class=note><strong>Note:</strong> the specificity of the styles specified in an HTML <code>style</code> attribute is described in CSS 2.1. <a href="#refsCSS21">[CSS21]</a>.<h2><a name=w3cselgrammar>10. The grammar of Selectors</a></h2><h3><a name=grammar>10.1. Grammar</a></h3><p>The grammar below defines the syntax of Selectors. It is globally LL(1) and can be locally LL(2) (but note that most UA's should not use it directly, since it doesn't express the parsing conventions). The format of the productions is optimized for human consumption and some shorthand notations beyond Yacc (see <a href="#refsYACC">[YACC]</a>) are used:<ul><li><b>*</b>: 0 or more<li><b>+</b>: 1 or more<li><b>?</b>: 0 or 1<li><b>|</b>: separates alternatives<li><b>[ ]</b>: grouping</ul><p>The productions are:<pre>selectors_group
  : selector [ COMMA S* selector ]*
  ;

selector
  : simple_selector_sequence [ combinator simple_selector_sequence ]*
  ;

combinator
  /* combinators can be surrounded by white space */
  : PLUS S* | GREATER S* | TILDE S* | S+
  ;

simple_selector_sequence
  : [ type_selector | universal ]
    [ HASH | class | attrib | pseudo | negation ]*
  | [ HASH | class | attrib | pseudo | negation ]+
  ;

type_selector
  : [ namespace_prefix ]? element_name
  ;

namespace_prefix
  : [ IDENT | '*' ]? '|'
  ;

element_name
  : IDENT
  ;

universal
  : [ namespace_prefix ]? '*'
  ;

class
  : '.' IDENT
  ;

attrib
  : '[' S* [ namespace_prefix ]? IDENT S*
        [ [ PREFIXMATCH |
            SUFFIXMATCH |
            SUBSTRINGMATCH |
            '=' |
            INCLUDES |
            DASHMATCH ] S* [ IDENT | STRING ] S*
        ]? ']'
  ;

pseudo
  /* '::' starts a pseudo-element, ':' a pseudo-class */
  /* Exceptions: :first-line, :first-letter, :before and :after. */
  /* Note that pseudo-elements are restricted to one per selector and */
  /* occur only in the last simple_selector_sequence. */
  : ':' ':'? [ IDENT | functional_pseudo ]
  ;

functional_pseudo
  : FUNCTION S* expression ')'
  ;

expression
  /* In CSS3, the expressions are identifiers, strings, */
  /* or of the form "an+b" */
  : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
  ;

negation
  : NOT S* negation_arg S* ')'
  ;

negation_arg
  : type_selector | universal | HASH | class | attrib | pseudo
  ;</pre><h3><a name=lex>10.2. Lexical scanner</a></h3><p>The following is the <a name=x3>tokenizer</a>, written in Flex (see <a href="#refsFLEX">[FLEX]</a>) notation. The tokenizer is case-insensitive.<p>The two occurrences of "\377" represent the highest character number that current versions of Flex can deal with (decimal 255). They should be read as "\4177777" (decimal 1114111), which is the highest possible code point in Unicode/ISO-10646. <a href="#refsUNICODE">[UNICODE]</a><pre>%option case-insensitive

ident     [-]?{nmstart}{nmchar}*
name      {nmchar}+
nmstart   [_a-z]|{nonascii}|{escape}
nonascii  [^\0-\177]
unicode   \\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
escape    {unicode}|\\[^\n\r\f0-9a-f]
nmchar    [_a-z0-9-]|{nonascii}|{escape}
num       [0-9]+|[0-9]*\.[0-9]+
string    {string1}|{string2}
string1   \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*\"
string2   \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*\'
invalid   {invalid1}|{invalid2}
invalid1  \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*
invalid2  \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*
nl        \n|\r\n|\r|\f
w         [ \t\r\n\f]*

%%

[ \t\r\n\f]+     return S;

"~="             return INCLUDES;
"|="             return DASHMATCH;
"^="             return PREFIXMATCH;
"$="             return SUFFIXMATCH;
"*="             return SUBSTRINGMATCH;
{ident}          return IDENT;
{string}         return STRING;
{ident}"("       return FUNCTION;
{num}            return NUMBER;
"#"{name}        return HASH;
{w}"+"           return PLUS;
{w}"&gt;"           return GREATER;
{w}","           return COMMA;
{w}"~"           return TILDE;
":not("          return NOT;
@{ident}         return ATKEYWORD;
{invalid}        return INVALID;
{num}%           return PERCENTAGE;
{num}{ident}     return DIMENSION;
"&lt;!--"           return CDO;
"--&gt;"            return CDC;

"url("{w}{string}{w}")"                           return URI;
"url("{w}([!#$%&*-~]|{nonascii}|{escape})*{w}")"  return URI;
U\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})?                return UNICODE_RANGE;

\/\*[^*]*\*+([^/*][^*]*\*+)*\/                    /* ignore comments */

.                return *yytext;</pre><h2><a name=downlevel>11. Namespaces and down-level clients</a></h2><p>An important issue is the interaction of CSS selectors with XML documents in web clients that were produced prior to this document. Unfortunately, due to the fact that namespaces must be matched based on the URI which identifies the namespace, not the namespace prefix, some mechanism is required to identify namespaces in CSS by their URI as well. Without such a mechanism, it is impossible to construct a CSS style sheet which will properly match selectors in all cases against a random set of XML documents. However, given complete knowledge of the XML document to which a style sheet is to be applied, and a limited use of namespaces within the XML document, it is possible to construct a style sheet in which selectors would match elements and attributes correctly.<p>It should be noted that a down-level CSS client will (if it properly conforms to CSS forward compatible parsing rules) ignore all <code>@namespace</code> at-rules, as well as all style rules that make use of namespace qualified element type or attribute selectors. The syntax of delimiting namespace prefixes in CSS was deliberately chosen so that down-level CSS clients would ignore the style rules rather than possibly match them incorrectly.<p>The use of default namespaces in CSS makes it possible to write element type selectors that will function in both namespace aware CSS clients as well as down-level clients. It should be noted that down-level clients may incorrectly match selectors against XML elements in other namespaces.<p>The following are scenarios and examples in which it is possible to construct style sheets which would function properly in web clients that do not implement this proposal.<ol><li><p>The XML document does not use namespaces.<ul><li>In this case, it is obviously not necessary to declare or use namespaces in the style sheet. Standard CSS element type and attribute selectors will function adequately in a down-level client.<li>In a CSS namespace aware client, the default behavior of element selectors matching without regard to namespace will function properly against all elements, since no namespaces are present. However, the use of specific element type selectors that match only elements that have no namespace ("<code>|name</code>") will guarantee that selectors will match only XML elements that do not have a declared namespace.</ul><li><p>The XML document defines a single, default namespace used throughout the document. No namespace prefixes are used in element names.<ul><li>In this case, a down-level client will function as if namespaces were not used in the XML document at all. Standard CSS element type and attribute selectors will match against all elements.</ul><li><p>The XML document does <b>not</b> use a default namespace, all namespace prefixes used are known to the style sheet author, and there is a direct mapping between namespace prefixes and namespace URIs. (A given prefix may only be mapped to one namespace URI throughout the XML document; there may be multiple prefixes mapped to the same URI).<ul><li>In this case, the down-level client will view and match element type and attribute selectors based on their fully qualified name, not the local part as outlined in the <a href="#typenmsp">Type selectors and Namespaces</a> section. CSS selectors may be declared using an escaped colon "<code>\:</code>" to describe the fully qualified names, e.g. "<code>html\:h1</code>" will match <code>&lt;html:h1&gt;</code>. Selectors using the qualified name will only match XML elements that use the same prefix. Other namespace prefixes used in the XML that are mapped to the same URI will not match as expected unless additional CSS style rules are declared for them.<li>Note that selectors declared in this fashion will <em>only</em> match in down-level clients. A CSS namespace aware client will match element type and attribute selectors based on the name's local part. Selectors declared with the fully qualified name will not match (unless there is no namespace prefix in the fully qualified name).</ul></ol><p>In other scenarios: when the namespace prefixes used in the XML are not known in advance by the style sheet author; or a combination of elements with no namespace are used in conjunction with elements using a default namespace; or the same namespace prefix is mapped to <em>different</em> namespace URIs within the same document, or in different documents; it is impossible to construct a CSS style sheet that will function properly against all elements in those documents, unless, the style sheet is written using a namespace URI syntax (as outlined in this document or similar) and the document is processed by a CSS and XML namespace aware client.<h2><a name=profiling>12. Profiles</a></h2><p>Each specification using Selectors must define the subset of W3C Selectors it allows and excludes, and describe the local meaning of all the components of that subset.<p>Non normative examples: <div class=profile><table class=tprofile><tbody><tr><th class=title colspan=2>Selectors profile<p>dummy only child<tr><th>Specification<td>CSS level 1<tr><th>Accepts<td>type selectors<br>class selectors<br>ID selectors<br>:link, :visited and :active pseudo-classes<br>descendant combinator<br>::first-line and ::first-letter pseudo-elements<tr><th>Excludes<td><p>universal selector<br>attribute selectors<br>:hover and :focus pseudo-classes<br>:target pseudo-class<br>:lang() pseudo-class<br>all UI element states pseudo-classes<br>all structural pseudo-classes<br>negation pseudo-class<br>all UI element fragments pseudo-elements<br>::before and ::after pseudo-elements<br>child combinators<br>sibling combinators<p>namespaces<tr><th>Extra constraints<td>only one class selector allowed per sequence of simple selectors</tbody></table><br><br><table class=tprofile><tbody><tr><th class=title colspan=2>Selectors profile<p>dummy only child<tr><th>Specification<td>CSS level 2<tr><th>Accepts<td>type selectors<br>universal selector<br>attribute presence and values selectors<br>class selectors<br>ID selectors<br>:link, :visited, :active, :hover, :focus, :lang() and :first-child pseudo-classes<br>descendant combinator<br>child combinator<br>adjacent sibling combinator<br>::first-line and ::first-letter pseudo-elements<br>::before and ::after pseudo-elements<tr><th>Excludes<td><p>content selectors<br>substring matching attribute selectors<br>:target pseudo-classes<br>all UI element states pseudo-classes<br>all structural pseudo-classes other than :first-child<br>negation pseudo-class<br>all UI element fragments pseudo-elements<br>general sibling combinators<p>namespaces<tr><th>Extra constraints<td>more than one class selector per sequence of simple selectors (CSS1 constraint) allowed</tbody></table><p>In CSS, selectors express pattern matching rules that determine which style rules apply to elements in the document tree.<p>The following selector (CSS level 2) will <b>match</b> all anchors <code>a</code> with attribute <code>name</code> set inside a section 1 header <code>h1</code>:<pre>h1 a[name]</pre><p>All CSS declarations attached to such a selector are applied to elements matching it. </div> <div class=profile><table class=tprofile><tbody><tr><th class=title colspan=2>Selectors profile<p>dummy only child<tr><th>Specification<td>STTS 3<tr><th>Accepts<td><p>type selectors<br>universal selectors<br>attribute selectors<br>class selectors<br>ID selectors<br>all structural pseudo-classes<br>all combinators<p>namespaces<tr><th>Excludes<td>non-accepted pseudo-classes<br>pseudo-elements<br><tr><th>Extra constraints<td>some selectors and combinators are not allowed in fragment descriptions on the right side of STTS declarations.</tbody></table><p>Selectors can be used in STTS 3 in two different manners:<ol><li>a selection mechanism equivalent to CSS selection mechanism: declarations attached to a given selector are applied to elements matching that selector,<li>fragment descriptions that appear on the right side of declarations.</ol></div><h2><a name=Conformance></a>13. Conformance and requirements</h2><p>This section defines conformance with the present specification only.<p>The inability of a user agent to implement part of this specification due to the limitations of a particular device (e.g., non interactive user agents will probably not implement dynamic pseudo-classes because they make no sense without interactivity) does not imply non-conformance.<p>All specifications reusing Selectors must contain a <a href="#profiling">Profile</a> listing the subset of Selectors it accepts or excludes, and describing the constraints it adds to the current specification.<p>Invalidity is caused by a parsing error, e.g. an unrecognized token or a token which is not allowed at the current parsing point.<p>User agents must observe the rules for handling parsing errors:<ul><li>a simple selector containing an undeclared namespace prefix is invalid<li>a selector containing an invalid simple selector, an invalid combinator or an invalid token is invalid.<li>a group of selectors containing an invalid selector is invalid.</ul><p>Specifications reusing Selectors must define how to handle parsing errors. (In the case of CSS, the entire rule in which the selector is used is dropped.)<h2><a name=Tests></a>14. Tests</h2><p>This specification has <a href="http://www.w3.org/Style/CSS/Test/CSS3/Selectors/current/">a test suite</a> allowing user agents to verify their basic conformance to the specification. This test suite does not pretend to be exhaustive and does not cover all possible combined cases of Selectors.<h2><a name=ACKS></a>15. Acknowledgements</h2><p>The CSS working group would like to thank everyone who has sent comments on this specification over the years.<p>The working group would like to extend special thanks to Donna McManus, Justin Baker, Joel Sklar, and Molly Ives Brower who perfermed the final editorial review.<h2><a name=references>16. References</a></h2><dl class=refs><dt>[CSS1]<dd><a name=refsCSS1></a> Bert Bos, H&aring;kon Wium Lie; "<cite>Cascading Style Sheets, level 1</cite>", W3C Recommendation, 17 Dec 1996, revised 11 Jan 1999<dd>(<code><a href="http://www.w3.org/TR/REC-CSS1">http://www.w3.org/TR/REC-CSS1</a></code>)<dt>[CSS21]<dd><a name=refsCSS21></a> Bert Bos, Tantek &Ccedil;elik, Ian Hickson, H&aring;kon Wium Lie, editors; "<cite>Cascading Style Sheets, level 2 revision 1</cite>", W3C Working Draft, 13 June 2005<dd>(<code><a href="http://www.w3.org/TR/CSS21">http://www.w3.org/TR/CSS21</a></code>)<dt>[CWWW]<dd><a name=refsCWWW></a> Martin J. D&uuml;rst, Fran&ccedil;ois Yergeau, Misha Wolf, Asmus Freytag, Tex Texin, editors; "<cite>Character Model for the World Wide Web</cite>", W3C Recommendation, 15 February 2005<dd>(<code><a href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a></code>)<dt>[FLEX]<dd><a name=refsFLEX></a> "<cite>Flex: The Lexical Scanner Generator</cite>", Version 2.3.7, ISBN 1882114213<dt>[HTML4]<dd><a name=refsHTML4></a> Dave Ragget, Arnaud Le Hors, Ian Jacobs, editors; "<cite>HTML 4.01 Specification</cite>", W3C Recommendation, 24 December 1999<dd>(<a href="http://www.w3.org/TR/html4/"><code>http://www.w3.org/TR/html4/</code></a>)<dt>[MATH]<dd><a name=refsMATH></a> Patrick Ion, Robert Miner, editors; "<cite>Mathematical Markup Language (MathML) 1.01</cite>", W3C Recommendation, revision of 7 July 1999<dd>(<code><a href="http://www.w3.org/TR/REC-MathML/">http://www.w3.org/TR/REC-MathML/</a></code>)<dt>[RFC3066]<dd><a name=refsRFC3066></a> H. Alvestrand; "<cite>Tags for the Identification of Languages</cite>", Request for Comments 3066, January 2001<dd>(<a href="http://www.ietf.org/rfc/rfc3066.txt"><code>http://www.ietf.org/rfc/rfc3066.txt</code></a>)<dt>[STTS]<dd><a name=refsSTTS></a> Daniel Glazman; "<cite>Simple Tree Transformation Sheets 3</cite>", Electricit&eacute; de France, submission to the W3C, 11 November 1998<dd>(<code><a href="http://www.w3.org/TR/NOTE-STTS3">http://www.w3.org/TR/NOTE-STTS3</a></code>)<dt>[SVG]<dd><a name=refsSVG></a> Jon Ferraiolo, &#34276;&#27810; &#28147;, Dean Jackson, editors; "<cite>Scalable Vector Graphics (SVG) 1.1 Specification</cite>", W3C Recommendation, 14 January 2003<dd>(<code><a href="http://www.w3.org/TR/SVG/">http://www.w3.org/TR/SVG/</a></code>)<dt>[UNICODE]<dd><a name=refsUNICODE></a> <cite><a href="http://www.unicode.org/versions/Unicode4.1.0/">The Unicode Standard, Version 4.1</a></cite>, The Unicode Consortium. Boston, MA, Addison-Wesley, March 2005. ISBN 0-321-18578-1, as amended by <a href="http://www.unicode.org/versions/Unicode4.0.1/">Unicode 4.0.1</a> and <a href="http://www.unicode.org/versions/Unicode4.1.0/">Unicode 4.1.0</a>.<dd>(<code><a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/</a></code>)<dt>[XML10]<dd><a name=refsXML10></a> Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, Fran&ccedil;ois Yergeau, editors; "<cite>Extensible Markup Language (XML) 1.0 (Third Edition)</cite>", W3C Recommendation, 4 February 2004<dd>(<a href="http://www.w3.org/TR/REC-xml/"><code>http://www.w3.org/TR/REC-xml/</code></a>)<dt>[XMLNAMES]<dd><a name=refsXMLNAMES></a> Tim Bray, Dave Hollander, Andrew Layman, editors; "<cite>Namespaces in XML</cite>", W3C Recommendation, 14 January 1999<dd>(<a href="http://www.w3.org/TR/REC-xml-names/"><code>http://www.w3.org/TR/REC-xml-names/</code></a>)<dt>[YACC]<dd><a name="refsYACC"></a> S. C. Johnson; "<cite>YACC &mdash; Yet another compiler compiler</cite>", Technical Report, Murray Hill, 1975</dl>